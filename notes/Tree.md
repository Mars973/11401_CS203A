# Tree（樹）

## 定義

Tree 是一種 **非線性（Non-linear）資料結構**，  
由一組 **節點（Node）** 所組成，用來表示具有 **階層關係（Hierarchical Structure）** 的資料。

在一棵樹中：
- 每個節點可以有 **零個或多個子節點**
- 除了根節點（Root）之外，每個節點 **只有一個父節點**
- 節點之間 **不存在循環（Cycle）**

---

## 基本特性

- **根節點（Root）**：樹的最上層節點，沒有父節點
- **子節點（Child）**：由某節點延伸出的下層節點
- **父節點（Parent）**：指向子節點的上層節點
- **葉節點（Leaf）**：沒有子節點的節點
- **邊（Edge）**：連接節點之間的關係

---

## 樹的性質

- 若樹中有 `n` 個節點，則一定有 `n - 1` 條邊
- 任意兩個節點之間 **只有一條唯一路徑**
- 樹是 **連通（Connected）且無環（Acyclic）** 的圖

---

## 節點結構示意

```c
      A
     / \
    B   C
   / \
  D   E
```

# Tree Traversal（樹的走訪）

Tree Traversal 是指 **依照特定順序訪問樹中所有節點一次** 的過程。

---

## 1. Preorder Traversal（前序走訪）

### 訪問順序
**Root → Left → Right**

### 說明
- 先處理根節點
- 再走訪左子樹
- 最後走訪右子樹

### 適合用途
- 複製樹結構
- 輸出樹的結構
- 表示運算式的前序表示法（Prefix）

### 範例
```c
      A
     / \
    B   C
   / \
  D   E
```
**前序結果：**
```c
A B D E C
```

## 2. Inorder Traversal（中序走訪）

### 訪問順序
**Left → Root → Right**

---

### 說明
- 先走訪左子樹
- 再處理根節點
- 最後走訪右子樹

---

### 適合用途
- **Binary Search Tree（BST）** 的中序走訪會得到 **排序後的結果**
- 轉換為 **中序表示法（Infix）**

---

### 範例

```c
      A
     / \
    B   C
   / \
  D   E
```
**中序結果:**
```c
D B E A C
```

## 3. Postorder Traversal（後序走訪）

### 訪問順序
**Left → Right → Root**

---

### 說明
- 先走訪左子樹
- 再走訪右子樹
- 最後處理根節點

---

### 適合用途
- 刪除整棵樹（先刪子節點，再刪父節點）
- 計算運算式的值
- 轉換為後序表示法（Postfix）

---

### 範例

```c
      A
     / \
    B   C
   / \
  D   E
```
**後序結果:**
```c
D E B C A
```

# 樹的幾種類型（Types of Trees）

---

## 1. General Tree（一般樹）

### 定義
- 每個節點可以有 **任意數量的子節點**
- 不限二元（不限左右子樹）

### 特點
- 適合表示 **層級資料**，如公司組織架構、檔案系統
- 沒有搜尋效率保證，需要遍歷
- 常用 **Linked List 或 Array of Children** 表示子節點

```c
    A
  / | \
 B  C  D
   / \
  E   F
```
---

## 2. Binary Tree（二元樹）

### 定義
每個節點最多有 **兩個子節點（Left, Right）** 的樹。

### 特點
- 子節點數 ≤ 2
- 高度可能不平衡
- 常用於運算式樹、BST、Heap

```c
    A
   / \
  B   C
 / \
D   E
```
---

## 3. Full Binary Tree（滿二元樹）

### 定義
每個節點要麼是 **葉節點**，要麼有 **兩個子節點**。

### 特點
- 所有非葉節點都有左右兩個孩子
- 節點數與高度有固定關係

```c
    A
   / \
  B   C
 / \  / \
D  E F   G
```
---

## 4. Complete Binary Tree（完全二元樹）

### 定義
- 所有層節點都填滿，**除了最後一層**，且最後一層節點 **靠左排列**

### 特點
- 常用於 **Heap（堆）** 實作
- 方便用陣列表示

```c
    A
   / \
  B   C
 / \  /
D  E F
```
---

## 5. Perfect Binary Tree（完美二元樹）

### 定義
- 滿二元樹且**所有葉節點在同一層**
- 節點數 = 2^h - 1（h = 樹高）

### 特點
- 高度最小化
- 節點分布非常均勻

```c
    A
   / \
  B   C
 / \  / \
D  E F  G
```
---

## 6. Binary Search Tree（BST，二元搜尋樹）

### 定義
- 左子樹節點值 < 根節點值
- 右子樹節點值 > 根節點值
- 每棵子樹也是 BST

### 特點
- 搜尋、插入、刪除平均 O(log n)
- 中序走訪可得到排序結果

```c
    8
   / \
  3   10
 / \    \
1   6    14
   / \   /
  4   7 13
```
---

## 7. AVL Tree（自平衡二元搜尋樹）

### 定義
- BST 的變種
- 每個節點的左右子樹高度差 ≤ 1

### 特點
- 保持平衡 → 保證 O(log n) 操作
- 需要旋轉操作（左旋、右旋）維持平衡

```c
    8
   / \
  4   12
 / \   / \
2   6 10 14
```
---

## 8. Red-Black Tree（紅黑樹）

### 定義
- BST 的變種
- 每個節點有顏色（紅/黑）
- 遵循紅黑規則保持樹高近似平衡

### 特點
- 保證最壞情況操作 O(log n)
- 常用於 STL 的 `map`、`set` 實作

---

## 9. Heap（堆）

### 定義
- 完全二元樹
- Max Heap：父節點 ≥ 子節點
- Min Heap：父節點 ≤ 子節點

### 特點
- 常用於 **優先隊列**
- 可以用陣列表示
- 插入、刪除操作 O(log n)

---

## 小結

- **General Tree**：多子節點樹，適合任意層級結構
- **Binary Tree** 系列：強調二元結構與形態  
- **BST / AVL / Red-Black**：強調搜尋效率和平衡性  
- **Heap**：強調父子大小關係

# 樹（Tree）的操作與時間複雜度

假設樹中有 `n` 個節點，樹高為 `h`。

---

## 1. 搜尋（Search）

- **操作說明**：尋找特定值的節點
- **時間複雜度**：
  - **一般 Binary Tree**：O(n)（最壞情況要遍歷所有節點）
  - **Binary Search Tree (BST)**：O(h) 平均 O(log n)（若平衡）
  - **AVL / Red-Black Tree**：O(log n)（自動保持平衡）

---

## 2. 插入（Insert）

- **操作說明**：將新節點加入樹
- **時間複雜度**：
  - **Binary Tree**：O(n)（可能需要遍歷）
  - **BST**：O(h) 平均 O(log n)
  - **AVL / Red-Black Tree**：O(log n)（插入後可能需要旋轉調整平衡）

---

## 3. 刪除（Delete）

- **操作說明**：移除樹中某個節點
- **時間複雜度**：
  - **Binary Tree**：O(n)（可能需要遍歷整棵樹）
  - **BST**：O(h) 平均 O(log n)
  - **AVL / Red-Black Tree**：O(log n)（刪除後可能旋轉維持平衡）

---

## 4. 遍歷（Traversal）

- **操作說明**：依特定順序拜訪所有節點
- **時間複雜度**：
  - **Preorder / Inorder / Postorder / Level Order**：O(n)（每個節點拜訪一次）
- **空間複雜度**：
  - 遞迴：O(h)（呼叫堆疊）
  - 非遞迴 / Level Order（BFS）：O(n)（使用 queue）

---

## 5. 查找最小 / 最大值（Min / Max）

- **操作說明**：找 BST 或 Heap 中的最小或最大元素
- **時間複雜度**：
  - **BST**：O(h)（沿左子樹找最小，右子樹找最大）
  - **Heap**：O(1)（Max Heap 最大值在根，Min Heap 最小值在根）

---

## 6. 高度 / 層數計算（Height / Depth）

- **操作說明**：計算樹的高度
- **時間複雜度**：O(n)（需要遍歷整棵樹）

---

## 小結（考試重點）

| 操作 | Binary Tree | BST | AVL / Red-Black Tree | 說明 |
|------|------------|-----|-------------------|------|
| Search | O(n) | O(h) avg O(log n) | O(log n) | 平衡樹能保證搜尋快 |
| Insert | O(n) | O(h) avg O(log n) | O(log n) | AVL / RB 插入後需旋轉 |
| Delete | O(n) | O(h) avg O(log n) | O(log n) | AVL / RB 刪除後需旋轉 |
| Traversal | O(n) | O(n) | O(n) | 拜訪每個節點一次 |
| Min / Max | O(n) | O(h) | O(1) (Heap) | BST 左子樹最小，右子樹最大 |
| Height | O(n) | O(n) | O(log n) | 計算高度需遍歷整棵樹 |


