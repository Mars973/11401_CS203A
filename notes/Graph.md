# Graph（圖）

---

## 定義
Graph 是一種由 **頂點（Vertex, V）** 與 **邊（Edge, E）** 所組成的 **非線性資料結構**，  
用來表示物件之間的關係。

通常表示為：
```c
G = (V, E)
```

- `V`：頂點集合（Nodes）
- `E`：邊集合（Edges），用來連接兩個頂點

---

## 特點
- 不具有固定的階層結構（不同於 Tree）
- 可能存在 **迴圈（Cycle）**
- 任兩個節點之間 **可能有多條路徑**
- 可為 **有向或無向**
- 可為 **加權或非加權**

---

## 圖的種類

### 1. 無向圖（Undirected Graph）
- 邊沒有方向
```c
A ─── B
```

---

### 2. 有向圖（Directed Graph）
- 邊有方向（箭頭）
```c
A ───▶ B
```

---

### 3. 加權圖（Weighted Graph）
- 邊具有權重（距離、成本、時間）
```c
A ──5── B
```

---

### 4. 無權圖（Unweighted Graph）
- 邊沒有權重

---

## 與 Tree 的差別

| 項目 | Tree | Graph |
|----|----|----|
| 是否有根節點 | 有 | 不一定 |
| 是否有迴圈 | 無 | 可能有 |
| 節點關係 | 階層式 | 網狀 |
| 兩點間路徑 | 唯一 | 可能多條 |

---

## 常見應用
- 社群網路（好友關係）
- 地圖導航（最短路徑）
- 網路拓撲
- 課程先修關係
- AI 與遊戲路徑規劃

---

## 濃縮重點
**Graph 是由頂點與邊所組成的非線性資料結構，用來表示節點之間的關係，允許多條路徑與迴圈存在。**

# Graph 的表示法  
## Adjacency Matrix（鄰接矩陣） & Adjacency List（鄰接串列）

---

## 一、Adjacency Matrix（鄰接矩陣）

### 定義
使用一個 **二維陣列** 來表示圖中頂點之間是否有邊。

- `matrix[i][j] = 1`：頂點 i 與 j 之間有邊
- `matrix[i][j] = 0`：頂點 i 與 j 之間沒有邊  
（加權圖則存權重）

---

### 範例圖（無向圖）
```c
A ── B
|    |
C ── D
```

---

### 鄰接矩陣表示
```c
    A B C D
A [ 0 1 1 0 ]
B [ 1 0 0 1 ]
C [ 1 0 0 1 ]
D [ 0 1 1 0 ]
```

---

### 特點
- 判斷兩點是否相鄰：**O(1)**
- 空間需求大：**O(V²)**
- 適合 **稠密圖（Dense Graph）**

---

## 二、Adjacency List（鄰接串列）

### 定義
每個頂點都有一個串列，存放與該頂點相連的所有頂點。

---

### 範例圖（同上）
```c
A ── B
|    |
C ── D
```

---

### 鄰接串列表示
```c
A → B → C
B → A → D
C → A → D
D → B → C
```

---

### 特點
- 空間需求小：**O(V + E)**
- 遍歷鄰居效率高
- 判斷兩點是否相鄰：**O(deg(V))**
- 適合 **稀疏圖（Sparse Graph）**

---

## 三、加權圖表示方式

### 鄰接矩陣（加權）
```c
matrix[i][j] = weight
```

### 鄰接串列（加權）
```c
A → (B, 5) → (C, 2)
```


---

## 四、Adjacency Matrix vs Adjacency List 比較表

| 項目 | Adjacency Matrix | Adjacency List |
|----|-----------------|----------------|
| 使用結構 | 二維陣列 | 陣列 + Linked List |
| 空間複雜度 | O(V²) | O(V + E) |
| 判斷是否有邊 | O(1) | O(deg(V)) |
| 列出所有鄰居 | O(V) | O(deg(V)) |
| 適合圖類型 | 稠密圖 | 稀疏圖 |
| 常見用途 | 小圖、完全圖 | 大型圖、實務應用 |

---

## 五、考試重點一句話

> Adjacency Matrix 以空間換時間，適合稠密圖；  
> Adjacency List 以節省空間為主，適合稀疏圖。

# Graph 的基本操作（Operations）

假設：
- V = 頂點數（Vertices）
- E = 邊數（Edges）

---

## 1. Traversal（走訪）

假設：
- V = 頂點數（Vertices）
- E = 邊數（Edges）

---

## 1. BFS（Breadth-First Search，廣度優先搜尋）

### 定義
BFS 是一種 **由近到遠、逐層走訪** 圖或樹的搜尋方式。

---

### 作法
- 使用 **Queue（佇列）**
- 先走訪起點的所有鄰居，再往下一層

---

### 流程
1. 起點加入 Queue
2. 標記為已拜訪
3. 取出節點，將未拜訪的鄰居加入 Queue
4. 重複直到 Queue 為空

---

### 時間複雜度
```c
O(V + E)
```

### 為什麼？
- 每個頂點最多進出 Queue 一次 → O(V)
- 每條邊最多被檢查一次 → O(E)

---

### 空間複雜度
```c
O(V)
```
(Queue 最壞情況存所有節點）

---

### 適合用途
- 找 **最短路徑（無權圖）**
- 層級結構分析
- 判斷連通性

---

## 2. DFS（Depth-First Search，深度優先搜尋）

### 定義
DFS 是一種 **一路往深處走，走到底再回溯** 的搜尋方式。

---

### 作法
- 使用 **Stack** 或 **遞迴（Recursion）**

---

### 流程
1. 訪問起點
2. 選擇一個未拜訪的鄰居繼續走訪
3. 無路可走時回溯

---

### 時間複雜度
```c
O(V + E)
```

### 為什麼？
- 每個頂點最多拜訪一次 → O(V)
- 每條邊最多被走訪一次 → O(E)

---

### 空間複雜度
```c
O(V)
```
（遞迴深度或 Stack 最壞為 V）

---

### 適合用途
- 偵測 **Cycle（迴圈）**
- 拓樸排序（有向無環圖）
- 迷宮、路徑探索

---

## 3. Path（路徑尋找）

### 說明
- 判斷兩個頂點之間是否存在路徑
- BFS 或 DFS 都可實作

### 時間複雜度
```c
O(V + E)
```

---

## 4. Connectivity（連通性）

### 說明
- 判斷圖是否為連通圖
- 或找出連通元件（Connected Components）

### 作法
- 對未拜訪的節點重複執行 BFS / DFS

### 時間複雜度
```c
O(V + E)
```

---

## 5. Cycle Detection（環的偵測）

### 說明
- 判斷圖中是否存在 **Cycle（迴圈）**

### 常見方法
- **無向圖**：DFS + parent 記錄
- **有向圖**：DFS + recursion stack

### 時間複雜度
```c
O(V + E)
```

---

## BFS vs DFS 比較表

| 項目 | BFS | DFS |
|----|----|----|
| 搜尋方式 | 逐層 | 先深後廣 |
| 使用資料結構 | Queue | Stack / Recursion |
| 是否保證最短路徑 | ✅（無權圖） | ❌ |
| 空間需求 | 較高 | 較低 |
| 適合用途 | 最短路徑、層級 | Cycle、拓樸排序 |
| 時間複雜度 | O(V + E) | O(V + E) |

## 統整表格

| 操作 | 使用方法 | 時間複雜度 |
|----|--------|----------|
| BFS | Queue | O(V + E) |
| DFS | Stack / Recursion | O(V + E) |
| Path Finding | BFS / DFS | O(V + E) |
| Connectivity | BFS / DFS | O(V + E) |
| Cycle Detection | DFS | O(V + E) |

---



## 補充重點

> Graph 的大多數基本操作皆可透過 BFS 或 DFS 完成，其時間複雜度為 O(V + E)，因為每個頂點與邊最多被訪問一次。
